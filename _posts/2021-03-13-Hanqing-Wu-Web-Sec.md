---
layout:       post
title:        "Web安全总结"
subtitle:     "摘自吴翰清《Web安全》"
date:         2021-03-13 21:05:43
author:       "NeptLiang"
header-img:   "img/home-bg.jpg"
header-mask:  0.3
catalog:      true
multilingual: false
tags:
    - Sec
	- WebSec
---


# 第4章 跨站点请求伪造（CSRF）

**CSRF**的全名是Cross Site Request Forgery，翻译成中文就是跨站点请求伪造。

## 4.1 CSRF简介

仅仅诱使用户访问了一个页面，就以该用户身份在第三方站点里执行了一次操作。这个请求是攻击者所**伪造的**，所以这种攻击就叫做“跨站点请求伪造”。

## 4.2 CSRF进阶

### 4.2.1 浏览器的Cookie策略

* 在上节提到的例子里，伪造的请求之所以能够被服务器验证通过，是因为用户的浏览器成功发送了Cookie的缘故。

* 浏览器所持有的Cookie分为两种：

	* 一种是“**Session Cookie**”，又称“**临时Cookie**”；
	* 另一种是“**Third-party Cookie**”，也称为“**本地Cookie**”。

* 两者的区别在于，
	
	* Third-party Cookie是服务器在Set-Cookie时**指定了Expire时间**，只有**到了Expire时间后**Cookie才会失效，所以这种Cookie会保存在本地；
	* 而Session Cookie则**没有指定Expire时间**，所以**浏览器关闭后**，Session Cookie就失效了。

		在浏览网站的过程中，若是一个网站设置了Session Cookie，那么在浏览器进程的生命周期内，即使浏览器新打开了Tab页，Session Cookie也都是有效的。
		
	* Session Cookie保存在浏览器进程的**内存空间**中；
	* 而Third-party Cookie则保存在**本地**。

* 如果浏览器**从一个域的页面中，要加载另一个域的资源**，由于安全原因，某些浏览器会**阻止Third-party Cookie的发送**。

	IE出于安全考虑，默认禁止了浏览器在`<img>`、`<iframe>`、`<script>`、`<link>`等标签中发送第三方Cookie。

	在Firefox中，默认策略是允许发送第三方Cookie的。

	对于IE浏览器，攻击者则需要精心构造攻击环境，比如诱使用户在当前浏览器中先访问目标站点，使得Session Cookie有效，再实施CSRF攻击。

	在当前的主流浏览器中，默认会拦截Third-party Cookie的有：IE 6、IE 7、IE 8、Safari；不会拦截的有：Firefox 2、Firefox 3、Opera、Google Chrome、Android等。

	但若CSRF攻击的目标并不需要使用Cookie，则也不必顾虑浏览器的Cookie策略了。

### 4.2.2 P3P头的副作用

浏览器拦截第三方Cookie的发送，在某种程度上来说降低了CSRF攻击的威力。可是这一情况在“P3P头”介入后变得复杂起来。

---


# 第9章 认证与会话管理

## 9.1 Who am I?

* 认证的目的是为了认出用户是谁，而授权的目的是为了决定用户能够做什么。

## 9.2 密码的那些事儿

* 密码是最常见的一种认证手段
	* 密码的优点是使用成本低，认证过程**实现起来很简单**；
	* 缺点是密码认证是一种比较弱的安全方案，**可能会被猜解**

* “**密码强度**”是设计密码认证方案时第一个需要考虑的问题

	一般在用户注册时，网站告知用户其所使用密码的复杂度

* 目前并没有一个标准的密码策略，但是根据OWASP推荐的一些最佳实践，我们可以对密码策略稍作总结。

	* 密码长度方面：
		* 普通应用要求长度为**6位以上**；
		* 重要应用要求长度为**8位以上**，并考虑**双因素认证**。
	* 密码复杂度方面：
		* 密码区分大小写字母
		* 密码为
			* 大写字母
			* 小写字母
			* 数字
			* 特殊符号
			中**两种以上的组合**；
		* 不要有连续性的字符，比如1234abcd，这种字符顺着人的思路，所以很容易猜解；
		* 尽量避免出现重复的字符，比如1111。
	
* 除了OWASP推荐的策略外，还需要注意，不要使用用户的公开数据，或者是于个人隐私相关的数据作为密码，比如不要使用
	* QQ号
	* 身份证号码
	* 昵称
	* 电话号码（含手机号码）
	* 生日
	* 英文名
	* 公司名
	等作为密码

* 密码必须以**不可逆的加密算法，或者是单向散列函数算法**，加密后存储在数据库中。

* 为了避免密码哈希值泄露后能够直接通过彩虹表查询出密码明文，再计算密码明文的哈希值时，增加一个“**Salt**”。

	“Salt”是一个**随机字符串**，它的作用是为了增加明文的复杂度，并能使得彩虹表一类的攻击失效。

	Salt应该保存在服务器端的**配置文件**中，并妥善保管。

## 9.3 多因素认证

* 支付宝就提供很多种不同的认证手段：
	
	* 支付密码
	* 手机动态口令
	* 数字证书
	* 宝令
	* 支付盾
	* 第三方证书

	等都可用于用户认证。

## 9.4 Session与认证

* 	为了告诉服务器应该使用哪一个Session，浏览器需要把当前用户持有的SessionID告知服务器。

	* 最常见的做法就是**把SessionID加密后保存在Cooike中**，因为Cookie会随着HTTP请求头发送，且**受到浏览器同源策略的保护**。

* Session劫持就是一种**窃取用户SessionID**后，使用该SessionID登录进目标账户，此时实际上是使用了目标账户的有效Session。
	
	如果SessionID是保存在Cookie中的，则可以称为Cookie劫持。

* Cookie泄露的途径有很多，最常见的有XSS、网络Sniff，以及本地木马窃取。

	通过给Cookie标记**httponly**，可以有效地缓解CSS窃取Cookie的问题。

	但是其他的泄露途径，比如网络被嗅探，或者Cookie文件被窃取，则会设计客户端的环境安全，需要从客户端着手解决。

* SessionID除了可以保存在Cookie中外，还可以保存在URL中，作为请求的一个参数。但是这种方式的安全性难以经受考验。

	在手机操作系统中，由于很多手机浏览器暂不支持Cookie，所以只能将SessionID作为URL的一个参数用于认证。
	
	安全研究者kxlzx曾经在博客上列出过一些无线WAP中因为sid泄露所导致的安全漏洞。其中一个典型的场景就是通过Referer泄露URL中的sid，QQ的WAP邮箱曾经出过此漏洞。

* **在生成SessionID时，需要保证足够的随机性**，比如采用足够强的伪随机数生成算法。

## 9.5 Session Fixation

* 在用户登录网站的过程中，如果登录前后用户的SessionID没有发生变化，则会存在Session Fixation问题。

	用户Ⅹ先获取到一个未经认证的SessionID，然后将这个SessionID交给用户Y去认证，Y完成认证后，服务器并未更新此SessionID的值（注意是未改变SessionID，而不是未改变Session），所以Ⅹ可以直接凭借此SessionID登录进Y的账户。

	Ⅹ如何才能让Y使用这个SessionID呢?如果SessionID保存在Cookie中，比较难做到这一点。但若是SessionID保存在URL中，则Ⅹ只需要诱使Y打开这个URL即可。在上一节中提到的sid，就需要认真考虑Session Fixation。

	在discuz 7.2 的WAP版本中，就存在这样的一个Session Fixation攻击。

* 解决Session Fixation的正确做法是，**在登录完成后，重写SessionID**。

## 9.6 Session保持

* 一般的应用都会给session设置一个失效时间，当到达失效时间后，Session将被销毁。

	但有一些系统，出于用户体验的考虑，只要这个用户还“活着”，就不会让这个用户的Session失效。从而可以通过**不停地发起访问请求**，让Session一直“活”下去。

	而Cookie是可以完全由客户端控制的，通过发送带有自定义Cookie头的HTTP包，也能实现同样的效果。

	在Web开发中，网站访问量如果比较大，维护Session可能会给网站带来巨大的负担。因此，有一种做法，就是服务器端不维护Session，而把Session放在Cookie中加密保存。当浏览器访问网站时，会自动带上Cookie，服务器端只需要解密Cookie即可得到当前用户的Session了。这样的Session如何使其过期呢?很多应用都是利用**Cookie的Expire标签**来控制Session的失效时间，这就给了攻击者可乘之机。

	Cookie的Expire时间是完全可以由客户端控制的。篡改这个时间，并使之永久有效，就有可能获得一个永久有效的Session，而服务器端是完全无法察觉的。

	攻击者**甚至可以为Session Cookie增加一个Expire时间**，使得原本浏览器关闭就会失效的Cookie持久化地保存在本地，变成一个第三方Cookie（third-party cookie）。

* 如何对抗这种Session保持攻击呢？

	* **常见的做法是在一定时间后，强制销毁Session**，这个时间可以是从用户登录的时间算起，设定一个阈值，比如3天后就强制Session过期。

	* 但强制销毁Session可能会影响到一些正常的用户，还可以选择的方法是**当用户客户端发生变化时，要求用户重新登录**。比如用户的IP、UserAgent等信息发生了变化，就可以强制销毁当前的Session，并要求用户重新登录。

	* 还需要考虑的是**同一用户可以同时拥有几个有效Session**。
	
		若每个用户只允许拥有一个Session，则攻击者想要一直保持一个Session也是不太可能的。

## 9.7 单点登录（SSO）

* **单点登录**的英文全称是Single Sign On，简称SSO。它希望用户只需要登录一次，就可以访问所有的系统。

	从用户体验的角度看，SSO无疑让用户的使用更加地方便；从安全的角度看，SSO把风险集中在单点上，这样做是**有利有弊**的。

	* SSO的**优点**在于
		* **风险集中化**，就只需要保护好这一个点。
		* 在单点处设计安全方案，甚至**可以考虑使用一些较“重”的方法**，比如双因素认证。
		* 此外对于一些中小网站来说，维护一份用户名、密码也是没有太大必要的开销，所以如果能将这个工作委托给一个可以信任的第三方，就可以将精力集中在业务上。

	* SSO的**缺点**同样也很明显，因为风险集中了，所以**单点一旦被攻破的话，后果会非常严重**，影响的范围将涉及所有使用单点登录的系统。

		降低这种风险的办法是**在一些敏感的系统里，再单独实现一些额外的认证机制**。比如网上支付平台，在付款前要求用户再输入一次密码，或者通过手机短信验证用户身份等。



---

***`//未完待Xu`***

---


# 参考文献

* [吴翰清《Web安全》]()

![公众号二维码](https://neptliang.github.io/img/Article/WeChatBlog.png)